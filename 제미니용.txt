### 1. 문제의 핵심: 보폭(Stride)의 차이

아두이노(AVR)에서:
*   **`char` (문자):** 1바이트 (방 1개 차지)
*   **`int` (정수):** 2바이트 (방 2개 차지)

OS 커널은 파일 이름을 저장할 때 **메모리를 아끼기 위해 1바이트씩 꽉꽉 채워서** 저장합니다. 그런데 VM이 이걸 **2바이트(int) 단위로 듬성듬성 읽으면** 문제가 생깁니다.

### 2. 시각적 예시 (메모리 지도)

메모리에 **"HELLO"**라는 글자가 저장되어 있다고 가정해 봅시다.

**[메모리 실제 상황 (1바이트 단위)]**
| 주소 | 1 | 2 | 3 | 4 | 5 |
|:---:|:---:|:---:|:---:|:---:|:---:|
| **값** | **'H'** | **'E'** | **'L'** | **'L'** | **'O'** |

---

#### 상황 A: VM이 `int` 단위로 읽을 때 (수정 전 코드)
`OP_PRTS`가 `global_heap`을 `int` 배열로 보고 읽으면, 인덱스를 1 늘릴 때마다 주소는 **2칸씩(2바이트)** 점프합니다.

1.  **첫 번째 읽기:** 주소 1, 2를 한꺼번에 읽음 (`'H'` + `'E'`).
    *   `(char)`로 캐스팅 -> 하위 바이트인 **'H'**만 남고 'E'는 버려짐.
    *   **출력:** `H`
2.  **두 번째 읽기 (인덱스 증가):** 주소 **3, 4**로 점프 (`'L'` + `'L'`).
    *   `(char)`로 캐스팅 -> 하위 바이트인 **'L'**만 남고 뒤의 'L'은 버려짐.
    *   **출력:** `L`
3.  **세 번째 읽기:** 주소 **5, 6**으로 점프 (`'O'` + `\0`).
    *   **출력:** `O`

**결과:** "HELLO"가 아니라 **"HLO"**가 출력됨 (중간 글자가 씹힘).

---

#### 상황 B: VM이 `char*` 단위로 읽을 때 (수정 후 코드)
`OP_PRTS` 내부에서 `(char*)global_heap`으로 형변환을 하면, 인덱스를 1 늘릴 때 주소도 **1칸씩(1바이트)** 이동합니다.

1.  **첫 번째:** 주소 1 읽음 -> **'H'**
2.  **두 번째:** 주소 2 읽음 -> **'E'**
3.  **세 번째:** 주소 3 읽음 -> **'L'**
4.  ...

**결과:** **"HELLO"** 정상 출력.

---

### 3. 지금 잘 나오는 이유는?

만약 선생님의 VM 코드가 `int` 단위로 읽는데도 "HELLO"가 잘 나온다면, **커널이 데이터를 저장할 때 애초에 듬성듬성 저장했기 때문**일 수 있습니다.

**[커널이 int 배열에 담았을 경우]**
| 주소 | 1 | 2 | 3 | 4 | 5 | 6 |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| **값** | **'H'** | 0 | **'E'** | 0 | **'L'** | 0 |

이렇게 되어 있다면 `int`로 읽어도 잘 나옵니다. 하지만 이는 **메모리 낭비(2배)**가 심합니다.

### 결론

지금 당장 잘 나온다면 다행이지만, 나중에 **표준 C 문자열 함수(`strcpy`, `sprintf` 등)**를 사용하거나 메모리 효율을 높일 때는 **VM의 `OP_PRTS`를 `char*` 포인터 방식**으로 구현하는 것이 정석입니다.

**체크리스트:**
`VirtualMachine.cpp`의 `OP_PRTS` 부분에 `(char*)` 혹은 `(uint8_t*)` 캐스팅이 되어 있는지 나중에 한 번 확인해 보세요!